"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const axios_1 = __importDefault(require("axios"));
const xml2js = __importStar(require("xml2js"));
const HttpBaseResponse_1 = require("./HttpBaseResponse");
const GlobalConfig_1 = require("../GlobalConfig");
const RequestKey_1 = require("../constants/RequestKey");
const SDKError_1 = require("../../exception/SDKError");
const ServiceApiError_1 = require("../../exception/ServiceApiError");
const ServiceUsageError_1 = require("../../exception/ServiceUsageError");
const AuthenticationResponse_1 = require("../dto/response/AuthenticationResponse");
const AssetUploadUriResponse_1 = require("../dto/response/AssetUploadUriResponse");
const JobErrorResponse_1 = require("../dto/error/JobErrorResponse");
const PDFServicesApiSingleAssetResponse_1 = require("../dto/response/PDFServicesApiSingleAssetResponse");
const PDFServicesApiMultiAssetResponse_1 = require("../dto/response/PDFServicesApiMultiAssetResponse");
const PDFServicesApiPDFPropertiesResponse_1 = require("../dto/response/PDFServicesApiPDFPropertiesResponse");
const PDFServicesApiAutotagResponse_1 = require("../dto/response/PDFServicesApiAutotagResponse");
const PDFServicesApiExtractResponse_1 = require("../dto/response/PDFServicesApiExtractResponse");
const PDFServicesApiJobStatusResponse_1 = require("../dto/response/PDFServicesApiJobStatusResponse");
const AssetDownloadUriResponse_1 = require("../dto/response/AssetDownloadUriResponse");
const UsernamePasswordCredentials_1 = require("../../config/proxy/UsernamePasswordCredentials");
const https_proxy_agent_1 = require("https-proxy-agent");
const Logger_1 = __importDefault(require("../Logger"));
class HttpClient {
    constructor() {
        this.axiosInstance = axios_1.default.create({
            maxRedirects: 0
        });
    }
    static getInstance() {
        if (!HttpClient.httpClient) {
            HttpClient.httpClient = new HttpClient();
        }
        return HttpClient.httpClient;
    }
    async execute(baseRequest, responseType) {
        await baseRequest.authenticate();
        const axiosRequestConfig = this.createAxiosRequestConfig(baseRequest);
        if (axiosRequestConfig.proxy && axiosRequestConfig.proxy.auth) {
            const username = axiosRequestConfig.proxy.auth.username;
            const password = axiosRequestConfig.proxy.auth.password;
            const protocol = axiosRequestConfig.proxy.protocol;
            const host = axiosRequestConfig.proxy.host;
            const port = axiosRequestConfig.proxy.port;
            axiosRequestConfig.httpsAgent = new https_proxy_agent_1.HttpsProxyAgent(`${protocol}://${username}:${password}@${host}:${port}`);
            axiosRequestConfig.proxy = undefined;
        }
        try {
            const axiosResponse = await this.axiosInstance.request(axiosRequestConfig);
            return this.createHTTPBaseResponse(axiosResponse, baseRequest, responseType);
        }
        catch (error) {
            if (axios_1.default.isAxiosError(error)) {
                this.handleErrorResponse(error, baseRequest);
            }
            throw error;
        }
    }
    handleErrorResponse(error, baseRequest) {
        if (error.response) {
            if (GlobalConfig_1.GlobalConfig.isCustomErrorMessageRequired(error.response.status)) {
                this.handleCustomErrorMessage(error.response);
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.CLOUD_UPLOAD ||
                baseRequest.requestKey === RequestKey_1.RequestKey.CLOUD_DOWNLOAD) {
                this.handleCloudAPIErrorResponse(error.response);
            }
            else {
                this.handlePDFServicesAPIErrorResponse(error.response);
            }
        }
        else {
            // Something happened in setting up the request that triggered an Error
            Logger_1.default.error("Error setting up the request:", error.message);
            throw new SDKError_1.SDKError(error.message);
        }
    }
    handleCustomErrorMessage(errorResponse) {
        const responseStatus = errorResponse.status, errorMessage = GlobalConfig_1.GlobalConfig.getCustomErrorMessage(responseStatus), requestId = errorResponse.headers["x-request-id"];
        Logger_1.default.error(`Gateway error (http status code=${responseStatus}, errorMessage=${errorMessage}, requestId=${requestId})`);
        throw new ServiceApiError_1.ServiceApiError(errorMessage, requestId, responseStatus);
    }
    handlePDFServicesAPIErrorResponse(errorResponse) {
        const responseStatus = errorResponse.status, errorMessage = errorResponse.data.error?.message, errorCode = errorResponse.data.error?.code, requestId = errorResponse.headers["x-request-id"];
        Logger_1.default.error(`Error while processing the http request (http status code=${responseStatus},` +
            ` errorCode=${errorCode}, errorMessage=${errorMessage}, requestId=${requestId})`);
        if (responseStatus === 429) {
            throw new ServiceUsageError_1.ServiceUsageError(errorMessage, requestId, responseStatus, errorCode);
        }
        else {
            throw new ServiceApiError_1.ServiceApiError(errorMessage, requestId, responseStatus, errorCode);
        }
    }
    handleCloudAPIErrorResponse(errorResponse) {
        // Parse the XML response
        xml2js.parseString(errorResponse.data, (err, result) => {
            if (err) {
                Logger_1.default.error("Error parsing XML:", err);
                return;
            }
            // Extract data from the parsed result
            const errorCode = result.Error.Code[0], errorMessage = result.Error.Message[0], requestId = result.Error.RequestId[0], responseStatus = errorResponse.status;
            Logger_1.default.error(`Error while processing the http request (http status code=${responseStatus}, errorCode=${errorCode}` +
                `, errorMessage=${errorMessage}, requestId=${requestId})`);
            throw new ServiceApiError_1.ServiceApiError(errorMessage, requestId, responseStatus, errorCode);
        });
    }
    createHTTPBaseResponse(axiosResponse, baseRequest, responseType) {
        Logger_1.default.debug(`Response status ${axiosResponse.status}`);
        if (axiosResponse.status === 200) {
            if (baseRequest.requestKey === RequestKey_1.RequestKey.AUTHN_PDF_SERVICES_SPC) {
                const response = new AuthenticationResponse_1.AuthenticationResponse(axiosResponse.data.token_type, axiosResponse.data.access_token, axiosResponse.data.expires_in);
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: response
                });
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.CREATE_PRE_SIGNED_URI) {
                const response = new AssetUploadUriResponse_1.AssetUploadUriResponse(axiosResponse.data.uploadUri, axiosResponse.data.assetID);
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: response
                });
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.CLOUD_UPLOAD) {
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: ""
                });
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.JOB_STATUS) {
                const errorResponse = new JobErrorResponse_1.JobErrorResponse(axiosResponse.data.error?.code, axiosResponse.data.error?.message, axiosResponse.data.error?.status);
                let response;
                if (responseType === PDFServicesApiSingleAssetResponse_1.PDFServicesApiSingleAssetResponse) {
                    response = new PDFServicesApiSingleAssetResponse_1.PDFServicesApiSingleAssetResponse(axiosResponse.data.asset, errorResponse, axiosResponse.data.status);
                }
                else if (responseType === PDFServicesApiMultiAssetResponse_1.PDFServicesApiMultiAssetResponse) {
                    response = new PDFServicesApiMultiAssetResponse_1.PDFServicesApiMultiAssetResponse(axiosResponse.data.assetList, axiosResponse.data.asset, errorResponse, axiosResponse.data.status);
                }
                else if (responseType === PDFServicesApiPDFPropertiesResponse_1.PDFServicesApiPDFPropertiesResponse) {
                    response = new PDFServicesApiPDFPropertiesResponse_1.PDFServicesApiPDFPropertiesResponse(axiosResponse.data.metadata, errorResponse, axiosResponse.data.status);
                }
                else if (responseType === PDFServicesApiAutotagResponse_1.PDFServicesApiAutotagResponse) {
                    response = new PDFServicesApiAutotagResponse_1.PDFServicesApiAutotagResponse(axiosResponse.data["tagged-pdf"], axiosResponse.data.report, axiosResponse.data.resource, errorResponse, axiosResponse.data.status);
                }
                else if (responseType === PDFServicesApiExtractResponse_1.PDFServicesApiExtractResponse) {
                    response = new PDFServicesApiExtractResponse_1.PDFServicesApiExtractResponse(axiosResponse.data.content, axiosResponse.data.resource, errorResponse, axiosResponse.data.status);
                }
                else if (responseType === PDFServicesApiJobStatusResponse_1.PDFServicesApiJobStatusResponse) {
                    response = new PDFServicesApiJobStatusResponse_1.PDFServicesApiJobStatusResponse(axiosResponse.data.status, errorResponse);
                }
                else {
                    throw new SDKError_1.SDKError(`Invalid response type: ${responseType}`);
                }
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: response
                });
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.CLOUD_DOWNLOAD) {
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: "",
                    responseContent: axiosResponse.data
                });
            }
            else if (baseRequest.requestKey === RequestKey_1.RequestKey.GET_ASSET) {
                const response = new AssetDownloadUriResponse_1.AssetDownloadUriResponse(axiosResponse.data.downloadUri, axiosResponse.data.type, axiosResponse.data.size);
                return new HttpBaseResponse_1.HttpBaseResponse({
                    statusCode: axiosResponse.status,
                    headers: this.transformAxiosHeaders(axiosResponse.headers),
                    baseResponseDto: response
                });
            }
        }
        else if (axiosResponse.status === 201) {
            return new HttpBaseResponse_1.HttpBaseResponse({
                statusCode: axiosResponse.status,
                headers: this.transformAxiosHeaders(axiosResponse.headers),
                baseResponseDto: {}
            });
        }
        return new HttpBaseResponse_1.HttpBaseResponse({
            statusCode: axiosResponse.status,
            headers: this.transformAxiosHeaders(axiosResponse.headers),
            baseResponseDto: {}
        });
    }
    transformAxiosHeaders(axiosHeaders) {
        return JSON.parse(JSON.stringify(axiosHeaders));
    }
    createAxiosRequestConfig(baseRequest) {
        function createAxiosProxyConfig(proxyServerConfig) {
            if (proxyServerConfig) {
                if (proxyServerConfig.credentials) {
                    let username = "", password = "";
                    if (proxyServerConfig.credentials instanceof UsernamePasswordCredentials_1.UsernamePasswordCredentials) {
                        username = proxyServerConfig.credentials.username;
                        password = proxyServerConfig.credentials.password;
                    }
                    return {
                        protocol: proxyServerConfig.scheme,
                        host: proxyServerConfig.host,
                        port: proxyServerConfig.port,
                        auth: {
                            username: username,
                            password: password
                        }
                    };
                }
                else {
                    return {
                        protocol: proxyServerConfig.scheme,
                        host: proxyServerConfig.host,
                        port: proxyServerConfig.port
                    };
                }
            }
        }
        return {
            method: baseRequest.httpMethod,
            url: baseRequest.uriTemplate,
            data: baseRequest.data,
            headers: baseRequest.headers,
            timeout: baseRequest.httpRequestConfig?.timeout,
            responseType: baseRequest.responseType,
            proxy: createAxiosProxyConfig(baseRequest.httpRequestConfig?.proxyServerConfig)
        };
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=HttpClient.js.map