"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFServicesHelper = void 0;
const uuid_1 = require("uuid");
const ValidationUtil_1 = require("./util/ValidationUtil");
const AssetUploadUriRequest_1 = require("./dto/request/upload/AssetUploadUriRequest");
const IOUtil_1 = require("./util/IOUtil");
const CloudAsset_1 = require("../io/CloudAsset");
const DefaultRequestHeaders_1 = require("./http/DefaultRequestHeaders");
const ObjectUtil_1 = require("./util/ObjectUtil");
const HttpClient_1 = require("./http/HttpClient");
const PDFServicesResponse_1 = require("../PDFServicesResponse");
const PDFServicesJobStatus_1 = require("../PDFServicesJobStatus");
const PDFServicesApiJobStatusResponse_1 = require("./dto/response/PDFServicesApiJobStatusResponse");
const ServiceApiError_1 = require("../exception/ServiceApiError");
const PDFServicesJobStatusResponse_1 = require("../PDFServicesJobStatusResponse");
const SDKError_1 = require("../exception/SDKError");
const StringUtil_1 = require("./util/StringUtil");
const ResponseType_1 = require("./http/ResponseType");
const StreamAsset_1 = require("../io/StreamAsset");
const AssetDownloadUriResponse_1 = require("./dto/response/AssetDownloadUriResponse");
const PDFServicesApiSingleAssetResponse_1 = require("./dto/response/PDFServicesApiSingleAssetResponse");
const AutotagPDFResult_1 = require("../pdfjobs/result/AutotagPDFResult");
const PDFServicesApiAutotagResponse_1 = require("./dto/response/PDFServicesApiAutotagResponse");
const SplitPDFResult_1 = require("../pdfjobs/result/SplitPDFResult");
const PDFServicesApiMultiAssetResponse_1 = require("./dto/response/PDFServicesApiMultiAssetResponse");
const PDFPropertiesResult_1 = require("../pdfjobs/result/PDFPropertiesResult");
const PDFServicesApiPDFPropertiesResponse_1 = require("./dto/response/PDFServicesApiPDFPropertiesResponse");
const Metadata_1 = require("./dto/response/pdfproperties/Metadata");
const PDFProperties_1 = require("../pdfjobs/result/pdfproperties/PDFProperties");
const ExtractPDFResult_1 = require("../pdfjobs/result/ExtractPDFResult");
const PDFServicesApiExtractResponse_1 = require("./dto/response/PDFServicesApiExtractResponse");
const LinearizePDFResult_1 = require("../pdfjobs/result/LinearizePDFResult");
const CompressPDFResult_1 = require("../pdfjobs/result/CompressPDFResult");
const CombinePDFResult_1 = require("../pdfjobs/result/CombinePDFResult");
const ExportPDFResult_1 = require("../pdfjobs/result/ExportPDFResult");
const OCRResult_1 = require("../pdfjobs/result/OCRResult");
const ProtectPDFResult_1 = require("../pdfjobs/result/ProtectPDFResult");
const RemoveProtectionResult_1 = require("../pdfjobs/result/RemoveProtectionResult");
const CreatePDFResult_1 = require("../pdfjobs/result/CreatePDFResult");
const HTMLToPDFResult_1 = require("../pdfjobs/result/HTMLToPDFResult");
const InsertPagesResult_1 = require("../pdfjobs/result/InsertPagesResult");
const ReplacePagesResult_1 = require("../pdfjobs/result/ReplacePagesResult");
const ReorderPagesResult_1 = require("../pdfjobs/result/ReorderPagesResult");
const DeletePagesResult_1 = require("../pdfjobs/result/DeletePagesResult");
const RotatePagesResult_1 = require("../pdfjobs/result/RotatePagesResult");
const PDFElectronicSealResult_1 = require("../pdfjobs/result/PDFElectronicSealResult");
const DocumentMergeResult_1 = require("../pdfjobs/result/DocumentMergeResult");
const RequestKey_1 = require("./constants/RequestKey");
const ExportPDFToImagesResult_1 = require("../pdfjobs/result/ExportPDFToImagesResult");
const Logger_1 = __importDefault(require("./Logger"));
class PDFServicesHelper {
    static async upload(context, readStream, mediaType) {
        Logger_1.default.info("Started uploading asset");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        const xRequestId = (0, uuid_1.v4)(), assetUploadURIRequest = new AssetUploadUriRequest_1.AssetUploadUriRequest(mediaType);
        Logger_1.default.debug("Creating preSignedURI with request id", xRequestId);
        const getUploadURIResponse = await this.createPreSignedUri(context, JSON.stringify(assetUploadURIRequest), xRequestId);
        Logger_1.default.debug("Uploading asset with request id", xRequestId);
        const buffer = await IOUtil_1.IOUtil.streamToByteArray(readStream);
        await this.uploadAsset(context, getUploadURIResponse.baseResponseDto.uploadURI, buffer, mediaType);
        Logger_1.default.info("Finished uploading asset");
        return new CloudAsset_1.CloudAsset(getUploadURIResponse.baseResponseDto.assetId);
    }
    static async submitJob(context, pdfServicesAPIRequest, xRequestId, operationHeaderInfoEndpointMap) {
        Logger_1.default.info(`Started submitting ${operationHeaderInfoEndpointMap.headerInfo} job`);
        Logger_1.default.debug(`Submitting ${operationHeaderInfoEndpointMap.headerInfo} job with request id ${xRequestId}`);
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.CREATE_JOB);
        baseHttpRequest.uriTemplate = baseHttpRequest.uriTemplate + operationHeaderInfoEndpointMap.endpoint;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.X_DCSDK_OPS_INFO_HEADER_NAME] =
            operationHeaderInfoEndpointMap.headerInfo;
        baseHttpRequest.data = ObjectUtil_1.ObjectUtil.modifyRequest(pdfServicesAPIRequest);
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_HEADER_NAME] =
            DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_APP_JSON;
        const httpClient = HttpClient_1.HttpClient.getInstance();
        Logger_1.default.info(`Finished submitting ${operationHeaderInfoEndpointMap.headerInfo} job`);
        return httpClient.execute(baseHttpRequest);
    }
    static async getJobResult(context, location, resultType) {
        Logger_1.default.info("Started getting job result");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        let pdfServicesResponse = null;
        while (!pdfServicesResponse || PDFServicesJobStatus_1.PDFServicesJobStatus.IN_PROGRESS === pdfServicesResponse.status) {
            pdfServicesResponse = await this.pollJob(context, location, resultType);
            const retryAfter = pdfServicesResponse?.retryInterval;
            Logger_1.default.debug(`Retry polling for job result after ${retryAfter} seconds`);
            await this.sleep(retryAfter);
        }
        Logger_1.default.info("Finished getting job result");
        return pdfServicesResponse;
    }
    static async getJobStatus(context, pollingURL) {
        Logger_1.default.info("Started getting job status");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        const xRequestId = (0, uuid_1.v4)();
        Logger_1.default.debug(`Getting job status with request id {} ${xRequestId}`);
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.JOB_STATUS);
        baseHttpRequest.uriTemplate = pollingURL;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        const httpClient = HttpClient_1.HttpClient.getInstance(), response = await httpClient.execute(baseHttpRequest, PDFServicesApiJobStatusResponse_1.PDFServicesApiJobStatusResponse), status = response.baseResponseDto.status, headers = response.headers, errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? response.baseResponseDto.errorResponse : null;
        if (errorResponse) {
            const requestId = headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY];
            throw new ServiceApiError_1.ServiceApiError(errorResponse.message, requestId, errorResponse.status, errorResponse.code);
        }
        Logger_1.default.info("Finished getting job status");
        return new PDFServicesJobStatusResponse_1.PDFServicesJobStatusResponse(status, headers);
    }
    static async getContent(context, asset) {
        Logger_1.default.info("Started getting content");
        if (!(asset instanceof CloudAsset_1.CloudAsset)) {
            throw new SDKError_1.SDKError("Only internal storage is supported for get content.");
        }
        StringUtil_1.StringUtil.requireNonBlank(asset.downloadURI, "Asset download URI");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        const downloadURI = asset.downloadURI;
        Logger_1.default.debug(`Getting content for asset id  ${asset.assetId}`);
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.CLOUD_DOWNLOAD);
        baseHttpRequest.responseType = ResponseType_1.ResponseType.STREAM;
        baseHttpRequest.uriTemplate = downloadURI;
        const httpClient = HttpClient_1.HttpClient.getInstance(), httpBaseResponse = await httpClient.execute(baseHttpRequest);
        Logger_1.default.info("Finished getting content");
        if (httpBaseResponse.responseContent)
            return new StreamAsset_1.StreamAsset(httpBaseResponse.responseContent, httpBaseResponse.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_HEADER_NAME]);
        else
            throw new SDKError_1.SDKError("Error occurred while downloading the asset");
    }
    static async deleteAsset(context, asset) {
        Logger_1.default.info("Started deleting asset");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        if (!(asset instanceof CloudAsset_1.CloudAsset)) {
            throw new SDKError_1.SDKError("Only internal storage is supported for delete asset.");
        }
        const xRequestId = (0, uuid_1.v4)(), assetId = asset.assetId;
        Logger_1.default.debug(`Deleting asset with asset id ${assetId} and request id ${xRequestId}`);
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.DELETE_ASSET);
        baseHttpRequest.uriTemplate = baseHttpRequest.uriTemplate + assetId;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        const httpClient = HttpClient_1.HttpClient.getInstance();
        await httpClient.execute(baseHttpRequest);
        Logger_1.default.info("Finished deleting asset");
    }
    static async refreshDownloadURI(context, asset) {
        Logger_1.default.info("Started refreshing asset");
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        if (!(asset instanceof CloudAsset_1.CloudAsset)) {
            throw new SDKError_1.SDKError("Only internal storage is supported for refresh download URI.");
        }
        const assetId = asset.assetId, xRequestId = (0, uuid_1.v4)();
        Logger_1.default.debug(`Refreshing asset with asset id ${assetId} and request id ${xRequestId}`);
        const httpClient = HttpClient_1.HttpClient.getInstance(), baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.GET_ASSET);
        baseHttpRequest.uriTemplate = baseHttpRequest.uriTemplate + assetId;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        const httpBaseResponse = await httpClient.execute(baseHttpRequest, AssetDownloadUriResponse_1.AssetDownloadUriResponse);
        const downloadURI = httpBaseResponse?.baseResponseDto?.downloadUri;
        Logger_1.default.info("Finished refreshing asset");
        return new CloudAsset_1.CloudAsset(assetId, downloadURI);
    }
    static async createPreSignedUri(context, requestBody, xRequestId) {
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.CREATE_PRE_SIGNED_URI);
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_HEADER_NAME] =
            DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_APP_JSON;
        baseHttpRequest.data = requestBody;
        const httpClient = HttpClient_1.HttpClient.getInstance();
        return httpClient.execute(baseHttpRequest);
    }
    static async uploadAsset(context, uploadURI, buffer, mediaType) {
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.CLOUD_UPLOAD);
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_HEADER_NAME] = mediaType;
        baseHttpRequest.data = buffer;
        baseHttpRequest.uriTemplate = uploadURI;
        const httpClient = HttpClient_1.HttpClient.getInstance();
        return httpClient.execute(baseHttpRequest);
    }
    static async fetchExtractContentJSON(context, content) {
        if (!content || !content.downloadURI) {
            throw new SDKError_1.SDKError("Content is null or download URI is null");
        }
        const downloadURI = content.downloadURI, baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.CLOUD_DOWNLOAD);
        baseHttpRequest.responseType = ResponseType_1.ResponseType.TEXT;
        baseHttpRequest.uriTemplate = downloadURI;
        const httpClient = HttpClient_1.HttpClient.getInstance(), httpBaseResponse = await httpClient.execute(baseHttpRequest);
        if (httpBaseResponse.responseContent)
            return JSON.parse(httpBaseResponse.responseContent);
        else
            throw new SDKError_1.SDKError("Error occurred while downloading the extract content JSON asset");
    }
    static async pollJob(context, location, resultType) {
        ValidationUtil_1.ValidationUtil.validateExecutionContext(context);
        const xRequestId = (0, uuid_1.v4)();
        Logger_1.default.debug(`Started polling for status with request id ${xRequestId}`);
        const baseHttpRequest = context.getBaseRequestFromRequestContext(RequestKey_1.RequestKey.JOB_STATUS);
        baseHttpRequest.uriTemplate = location;
        baseHttpRequest.headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY] = xRequestId;
        const httpClient = HttpClient_1.HttpClient.getInstance();
        let status, headers, result, errorResponse;
        if (this.getSingleAssetResultClasses().some((cls) => cls === resultType)) {
            const response = await httpClient.execute(baseHttpRequest, PDFServicesApiSingleAssetResponse_1.PDFServicesApiSingleAssetResponse), baseResponseDto = response.baseResponseDto;
            status = baseResponseDto.status;
            headers = response.headers;
            result = status === PDFServicesJobStatus_1.PDFServicesJobStatus.DONE ? new resultType(baseResponseDto.cloudAsset) : null;
            errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? baseResponseDto.errorResponse : null;
        }
        else if (resultType === AutotagPDFResult_1.AutotagPDFResult) {
            const response = await httpClient.execute(baseHttpRequest, PDFServicesApiAutotagResponse_1.PDFServicesApiAutotagResponse), baseResponseDto = response.baseResponseDto;
            status = baseResponseDto.status;
            headers = response.headers;
            result =
                status === PDFServicesJobStatus_1.PDFServicesJobStatus.DONE
                    ? new resultType(baseResponseDto.taggedPDF, baseResponseDto.report, baseResponseDto.resource)
                    : null;
            errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? baseResponseDto.errorResponse : null;
        }
        else if (resultType === SplitPDFResult_1.SplitPDFResult || resultType === ExportPDFToImagesResult_1.ExportPDFToImagesResult) {
            const response = await httpClient.execute(baseHttpRequest, PDFServicesApiMultiAssetResponse_1.PDFServicesApiMultiAssetResponse), baseResponseDto = response.baseResponseDto;
            status = baseResponseDto.status;
            headers = response.headers;
            result =
                status === PDFServicesJobStatus_1.PDFServicesJobStatus.DONE
                    ? new resultType(baseResponseDto.cloudAssets, baseResponseDto.cloudAsset)
                    : null;
            errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? baseResponseDto.errorResponse : null;
        }
        else if (resultType === PDFPropertiesResult_1.PDFPropertiesResult) {
            const response = await httpClient.execute(baseHttpRequest, PDFServicesApiPDFPropertiesResponse_1.PDFServicesApiPDFPropertiesResponse), baseResponseDto = response.baseResponseDto;
            status = baseResponseDto.status;
            headers = response.headers;
            const metadata = new Metadata_1.Metadata(baseResponseDto.metadata), pdfProperties = new PDFProperties_1.PDFProperties();
            Object.assign(pdfProperties, metadata);
            result =
                status === PDFServicesJobStatus_1.PDFServicesJobStatus.DONE
                    ? new resultType(pdfProperties, JSON.stringify(baseResponseDto.metadata))
                    : null;
            errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? baseResponseDto.errorResponse : null;
        }
        else if (resultType === ExtractPDFResult_1.ExtractPDFResult) {
            const response = await httpClient.execute(baseHttpRequest, PDFServicesApiExtractResponse_1.PDFServicesApiExtractResponse), baseResponseDto = response.baseResponseDto;
            status = baseResponseDto.status;
            headers = response.headers;
            let contentJSON;
            if (PDFServicesJobStatus_1.PDFServicesJobStatus.DONE && baseResponseDto.content)
                contentJSON = await this.fetchExtractContentJSON(context, baseResponseDto.content);
            result =
                status === PDFServicesJobStatus_1.PDFServicesJobStatus.DONE
                    ? new resultType(baseResponseDto.resource, baseResponseDto.content, contentJSON)
                    : null;
            errorResponse = status === PDFServicesJobStatus_1.PDFServicesJobStatus.FAILED ? baseResponseDto.errorResponse : null;
        }
        else {
            throw new TypeError(`No resultType found for ${resultType}`);
        }
        if (errorResponse) {
            const requestId = headers[DefaultRequestHeaders_1.DefaultRequestHeaders.REQUEST_ID_HEADER_KEY];
            throw new ServiceApiError_1.ServiceApiError(errorResponse.message, requestId, errorResponse.status, errorResponse.code);
        }
        Logger_1.default.debug(`Finished polling for status with request id ${xRequestId}`);
        return new PDFServicesResponse_1.PDFServicesResponse(status, headers, result);
    }
    static sleep(seconds) {
        return new Promise((resolve) => setTimeout(resolve, seconds ? seconds * 1000 : 0));
    }
    static getSingleAssetResultClasses() {
        return [
            LinearizePDFResult_1.LinearizePDFResult,
            CompressPDFResult_1.CompressPDFResult,
            CombinePDFResult_1.CombinePDFResult,
            ExportPDFResult_1.ExportPDFResult,
            OCRResult_1.OCRResult,
            ProtectPDFResult_1.ProtectPDFResult,
            RemoveProtectionResult_1.RemoveProtectionResult,
            CreatePDFResult_1.CreatePDFResult,
            HTMLToPDFResult_1.HTMLToPDFResult,
            InsertPagesResult_1.InsertPagesResult,
            ReplacePagesResult_1.ReplacePagesResult,
            ReorderPagesResult_1.ReorderPagesResult,
            DeletePagesResult_1.DeletePagesResult,
            RotatePagesResult_1.RotatePagesResult,
            PDFElectronicSealResult_1.PDFElectronicSealResult,
            DocumentMergeResult_1.DocumentMergeResult
        ];
    }
}
exports.PDFServicesHelper = PDFServicesHelper;
//# sourceMappingURL=PDFServicesHelper.js.map