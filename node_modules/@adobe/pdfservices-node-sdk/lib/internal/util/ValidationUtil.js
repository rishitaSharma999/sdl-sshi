"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationUtil = void 0;
const ObjectUtil_1 = require("./ObjectUtil");
const SDKError_1 = require("../../exception/SDKError");
const EncryptionAlgorithm_1 = require("../../pdfjobs/params/protectpdf/EncryptionAlgorithm");
const StringUtil_1 = require("./StringUtil");
const CustomErrorMessages_1 = require("../constants/CustomErrorMessages");
const ProxyScheme_1 = require("../../config/proxy/ProxyScheme");
const Region_1 = require("../../Region");
const NotifierType_1 = require("../../config/notifier/NotifierType");
const SignatureFormat_1 = require("../../pdfjobs/params/electronicseal/SignatureFormat");
const DocumentLevelPermission_1 = require("../../pdfjobs/params/electronicseal/DocumentLevelPermission");
const AppearanceItem_1 = require("../../pdfjobs/params/electronicseal/AppearanceItem");
const CloudAsset_1 = require("../../io/CloudAsset");
const ExternalAsset_1 = require("../../io/ExternalAsset");
class ValidationUtil {
    static validateExecutionContext(executionContext) {
        if (ObjectUtil_1.ObjectUtil.isNull(executionContext)) {
            throw new SDKError_1.SDKError("Execution Context not initialized before invoking the operation");
        }
        if (!executionContext.clientConfig) {
            throw new SDKError_1.SDKError("Client configuration not initialized before invoking the operation");
        }
        executionContext.validate();
    }
    static validateSplitPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Split PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.pageRanges, "Page Ranges");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.pageCount, "Page Count");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.fileCount, "File Count");
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageRanges) &&
            ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageCount) &&
            ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.fileCount)) {
            throw new TypeError("One of the options (page ranges/file count/page count) is required for splitting a " + "PDF document");
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageRanges)) {
            if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageCount) || !ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.fileCount)) {
                throw new TypeError("Only one of the options (page ranges/page count/file count) can be specified " +
                    "for splitting a PDF document");
            }
            if (params.pageRanges) {
                if (params.pageRanges?.ranges.length > ValidationUtil.SPLIT_PDF_OUTPUT_COUNT_LIMIT) {
                    throw new RangeError("Too many page ranges specified");
                }
                this.validatePageRangesOverlap(params.pageRanges);
                params.pageRanges.validate();
            }
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageCount)) {
            if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.fileCount)) {
                throw new TypeError("Only one of the options (page ranges/page count/file count) can be specified " +
                    "for splitting a PDF document");
            }
            if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.pageCount) && !ObjectUtil_1.ObjectUtil.isValidPositiveInteger(params.pageCount)) {
                throw new RangeError("Page count should be greater than 0");
            }
            return;
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.fileCount) && !ObjectUtil_1.ObjectUtil.isValidPositiveInteger(params.fileCount)) {
            throw new RangeError("File count should be greater than 0");
        }
        if (params.fileCount && params.fileCount > ValidationUtil.SPLIT_PDF_OUTPUT_COUNT_LIMIT) {
            throw new RangeError(`Input PDF file cannot be split into more than ${ValidationUtil.SPLIT_PDF_OUTPUT_COUNT_LIMIT} documents`);
        }
    }
    static validatePageRangesOverlap(pageRanges) {
        // Creating a copy in case the pageRange order matters in the original pageRanges
        const pageRangeList = [...pageRanges.ranges];
        pageRangeList.sort((a, b) => (a.start || 0) - (b.start || 0));
        for (let i = 1; i < pageRangeList.length; i++) {
            if (!pageRangeList[i - 1].end || (pageRangeList[i].start || 0) <= pageRangeList[i - 1].end) {
                throw new RangeError("The overlapping page ranges are not allowed");
            }
        }
    }
    static validateAssetWithPageOptions(input) {
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(input.asset)) {
            throw new TypeError("No input asset was set for the submitted job");
        }
        this.validatePageOptions(input);
    }
    static validatePageOptions(input) {
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(input.pageRanges)) {
            throw TypeError("No page options provided for combining files PDFs");
        }
        input.pageRanges.validate();
    }
    static validateProtectPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Protect PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.encryptionAlgorithm, "Encryption Algorithm");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.contentEncryption, "Content Encryption");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.permissions, "Permissions");
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.userPassword) && ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.ownerPassword)) {
            throw new TypeError("One of the password (user/owner) is required");
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.ownerPassword) && !ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.userPassword)) {
            if (params.ownerPassword === params.userPassword) {
                throw new TypeError("User and owner password cannot be same");
            }
        }
        // Validate user password
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.userPassword))
            this.validatePassword(params.userPassword, true, params.encryptionAlgorithm);
        // Validate owner password
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.ownerPassword))
            this.validatePassword(params.ownerPassword, false, params.encryptionAlgorithm);
        // OwnerPassword is mandatory in case the permissions are provided
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.permissions) &&
            params.permissions?.values.size !== 0 &&
            ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.ownerPassword))
            throw new TypeError("The document permissions cannot be applied without setting owner password");
    }
    static validatePassword(password, isUserPassword, encryptionAlgorithm) {
        if (StringUtil_1.StringUtil.isBlank(password)) {
            throw new TypeError(`${isUserPassword ? ValidationUtil.USER_STRING : ValidationUtil.OWNER_STRING} Password cannot be empty`);
        }
        if (password.length > ValidationUtil.PASSWORD_MAX_LENGTH) {
            throw new RangeError(`${isUserPassword ? ValidationUtil.USER_STRING : ValidationUtil.OWNER_STRING} Password length cannot exceed ${ValidationUtil.PASSWORD_MAX_LENGTH} bytes`);
        }
        // Password validation for AES_128 encryption algorithm
        if (encryptionAlgorithm === EncryptionAlgorithm_1.EncryptionAlgorithm.AES_128 && !this.isLatin(password)) {
            throw new TypeError(`${isUserPassword ? ValidationUtil.USER_STRING : ValidationUtil.OWNER_STRING} Password supports only LATIN-I characters for AES-128 encryption`);
        }
    }
    // check whether the password given with AES_128 encryption algorithm is in LATIN-I encoding or not
    static isLatin(password) {
        for (let character = 0; character < password.length; character++) {
            if (password.charCodeAt(character) > 255) {
                return false;
            }
        }
        return true;
    }
    static validateReorderPagesParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Reorder Pages Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.asset, "Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.pageRanges, "Page Ranges");
        if (params.pageRanges.isEmpty()) {
            throw new TypeError("No page ranges were set for the operation");
        }
        params.pageRanges.validate();
    }
    static validateReplaceFilesInputs(baseAsset, assetsToReplace) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(baseAsset, "Base asset");
        if (!assetsToReplace || assetsToReplace.size === 0) {
            throw new TypeError("No assets to replace in the base input asset");
        }
        for (const [key, value] of assetsToReplace) {
            if (key < 1) {
                throw new RangeError("Base asset page should be greater than 0");
            }
            this.validatePageRanges(value.pageRanges);
        }
    }
    static validateInsertAssetInputs(baseAsset, assetsToInsert) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(baseAsset, "Base asset");
        if (!assetsToInsert || assetsToInsert.size === 0) {
            throw new SDKError_1.SDKError("No assets to insert in the base input asset");
        }
        for (const [key, value] of assetsToInsert.entries()) {
            if (key < 1) {
                throw new RangeError("Base file page should be greater than 0");
            }
            for (const combinePDFJobInput of value) {
                this.validatePageRanges(combinePDFJobInput.pageRanges);
            }
        }
    }
    static validatePageRanges(pageRanges) {
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(pageRanges) || pageRanges.isEmpty()) {
            throw new RangeError("No page ranges were set for the operation");
        }
        pageRanges.validate();
    }
    static validateRotatePageActions(pageActions) {
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(pageActions) || pageActions.length === 0) {
            throw new RangeError("No rotation specified for the operation");
        }
        if (pageActions.length > this.PAGE_ACTIONS_MAX_LIMIT) {
            throw new RangeError("Too many rotations not allowed.");
        }
        for (const pageAction of pageActions) {
            if (pageAction.pageRanges.length === 0) {
                throw new RangeError("No page ranges were set for the operation");
            }
        }
    }
    static validateDocumentMergeParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Document Merge Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.jsonDataForMerge, "JSON Data for Merge");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.fragments, "Fragments");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputFormat, "Output Format");
        if (ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.jsonDataForMerge) ||
            Object.keys(JSON.parse(JSON.stringify(params.jsonDataForMerge))).length === 0) {
            throw new TypeError(`JSON Data for Merge ${CustomErrorMessages_1.CustomErrorMessages.GENERIC_CAN_NOT_BE_NULL_OR_EMPTY}`);
        }
        try {
            params.fragments?.forEach((fragment) => {
                JSON.parse(JSON.stringify(fragment));
            });
        }
        catch (e) {
            throw new TypeError(`Unable to read Fragments : ${e}`);
        }
    }
    static validateAutotagPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Auto-tag PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.generateReport, "Generate Report");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.shiftHeadings, "Shift Headings");
    }
    static validateRemoveProtectionParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Remove Protection Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.password, "Password");
        if (params.password.length > ValidationUtil.REMOVE_PROTECTION_PASSWORD_MAX_LENGTH) {
            throw new RangeError(`Allowed maximum length of password is
            ${ValidationUtil.REMOVE_PROTECTION_PASSWORD_MAX_LENGTH} characters`);
        }
    }
    static validateCompressPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Compress PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.compressionLevel, "Compression Level");
    }
    static validateCreatePDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Create PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.documentLanguage, "Document Language");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.createTaggedPDF, "Create Tagged PDF");
    }
    static validateDeletePagesParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Delete Pages Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.pageRanges, "Page Ranges");
        this.validatePageRanges(params.pageRanges);
    }
    static validateExportPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Export PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.targetFormat, "Export PDF Target Format");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.ocrLocale, "Export OCR Locale");
    }
    static validateExportPDFToImagesParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Export PDF To Images Params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.outputType, "Output Type");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.targetFormat, "Target Format");
    }
    static validateExtractPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Extract PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.tableStructureType, "Table Structure Type");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.addCharInfo, "Add Char Info");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.getStylingInfo, "Get Styling Info");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.elementsToExtractRenditions, "Elements To Extract Renditions");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.elementsToExtract, "Elements To Extract");
    }
    static validatePageLayoutParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Page Layout Params");
        if (!ObjectUtil_1.ObjectUtil.isUndefined(params.pageHeight)) {
            ObjectUtil_1.ObjectUtil.requireValidNonNegativeNumber(params.pageHeight, "Page Height");
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefined(params.pageWidth)) {
            ObjectUtil_1.ObjectUtil.requireValidNonNegativeNumber(params.pageHeight, "Page Width");
        }
    }
    static validateHTMLToPDFParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "HTML To PDF Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.includeHeaderFooter, "Include Header Footer");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.pageLayout, "Page Layout");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.dataToMerge, "Data to Merge");
        if (params.dataToMerge) {
            try {
                JSON.parse(JSON.stringify(params.dataToMerge));
            }
            catch (e) {
                throw new TypeError(`Unable to parse Data to Merge : ${e}`);
            }
        }
    }
    static validateOCRParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "OCR Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.ocrLocale, "OCR Locale");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.ocrType, "OCR Type");
    }
    static validatePDFPropertiesParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "PDF Properties Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.includePageLevelProperties, "Include Page Level Properties");
    }
    static validatePermissions(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Permissions params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.permissions, "Permissions");
    }
    static validateExternalAssetParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "External Asset params");
        StringUtil_1.StringUtil.requireNonBlank(params.uri, "URI");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.storageType, "Storage Type");
    }
    static validateProxyServerConfigParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Proxy server config params");
        StringUtil_1.StringUtil.requireNonBlank(params.host, "Proxy server host");
        ObjectUtil_1.ObjectUtil.requireValidNonNegativeInteger(params.port, "Proxy server port");
        if (params.port < 0 || params.port >= 65536) {
            throw new RangeError(`Invalid value for proxy port. It should be >= 0 and < 65536`);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.scheme, "Proxy server scheme");
        if (params.scheme) {
            this.validateProxyScheme(params.scheme);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.credentials, "Proxy server credentials");
    }
    static validateClientConfigParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Client config params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.timeout, "Timeout");
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.timeout) &&
            (params.timeout <= 0 || !ObjectUtil_1.ObjectUtil.isValidNumber(params.timeout))) {
            throw new RangeError(`Invalid value for timeout ${params.timeout}. Must be a valid integer greater than 0.`);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.region, "Region");
        this.validateRegion(params.region);
        ObjectUtil_1.ObjectUtil.requireNonNull(params.proxyServerConfig, "Proxy Server Config");
        if (!ObjectUtil_1.ObjectUtil.isUndefined(params.filePath)) {
            StringUtil_1.StringUtil.requireNonBlank(params.filePath, "File Path");
        }
    }
    static validateUsernamePasswordCredentialsParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Username password credentials params");
        StringUtil_1.StringUtil.requireNonBlank(params.username, "Username");
        StringUtil_1.StringUtil.requireNonBlank(params.password, "Password");
    }
    static validateProxyScheme(scheme) {
        for (const schemeValue of Object.values(ProxyScheme_1.ProxyScheme)) {
            if (scheme === schemeValue)
                return;
        }
        throw new TypeError("Invalid value for proxy scheme. Must be either HTTP or HTTPS.");
    }
    static validateRegion(region) {
        if (region) {
            for (const regionValue of Object.values(Region_1.Region)) {
                if (region === regionValue)
                    return;
            }
            throw new TypeError("Invalid value for region. Must be either US or EU.");
        }
    }
    static validateCallbackNotifierDataParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNull(params, "Callback Notifier Data params");
        StringUtil_1.StringUtil.requireNonBlank(params.url, "URL");
    }
    static validateNotifierConfigParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Notifier Config params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.type, "Notifier Type");
        this.validateNotifierType(params.type);
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.data, "Callback Notifier Data");
    }
    static validateNotifierType(type) {
        for (const typeValue of Object.values(NotifierType_1.NotifierType)) {
            if (type === typeValue)
                return;
        }
        throw new SDKError_1.SDKError("Invalid value for notifier type. Must be either callback.");
    }
    static validatePDFElectronicSealParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "PDF Electronic Seal Params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.signatureFormat, "Signature Format");
        this.validateSignatureFormat(params.signatureFormat);
        ObjectUtil_1.ObjectUtil.requireNonNull(params.documentLevelPermission, "Document Level Permission");
        this.validateDocumentLevelPermission(params.documentLevelPermission);
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.certificateCredentials, "Certificate Credentials");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.tsaOptions, "TSA Options");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.sealFieldOptions, "Seal Field Options");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.sealAppearanceOptions, "Seal Appearance Options");
    }
    static validateSignatureFormat(signatureFormat) {
        if (signatureFormat) {
            for (const signatureFormatValue of Object.values(SignatureFormat_1.SignatureFormat)) {
                if (signatureFormat === signatureFormatValue)
                    return;
            }
            throw new TypeError("Invalid value for signature format. Must be either PKCS7 or PADES.");
        }
    }
    static validateDocumentLevelPermission(documentLevelPermission) {
        if (documentLevelPermission) {
            for (const documentLevelPermissionValue of Object.values(DocumentLevelPermission_1.DocumentLevelPermission)) {
                if (documentLevelPermission === documentLevelPermissionValue)
                    return;
            }
            throw new TypeError(`Invalid value for document level permission.
             Must be one of ${Object.values(DocumentLevelPermission_1.DocumentLevelPermission)}`);
        }
    }
    static validateAppearanceOptions(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Appearance Options params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.items, "Items");
        params.items?.forEach((item) => {
            ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(item, "Appearance Item");
            this.validateAppearanceItem(item);
        });
    }
    static validateAppearanceItem(item) {
        for (const appearanceItemValue of Object.values(AppearanceItem_1.AppearanceItem)) {
            if (item === appearanceItemValue)
                return;
        }
        throw new TypeError(`Invalid value for appearance item. Must be one of ${Object.values(AppearanceItem_1.AppearanceItem)}`);
    }
    static validateCSCAuthContext(params) {
        ObjectUtil_1.ObjectUtil.requireNonNull(params, "CSC Auth Context params");
        StringUtil_1.StringUtil.requireNonBlank(params.accessToken, "Access Token");
        if (params.tokenType) {
            StringUtil_1.StringUtil.requireNonBlank(params.tokenType, "Token Type");
        }
    }
    static validateCSCCredential(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "CSC Credential params");
        StringUtil_1.StringUtil.requireNonBlank(params.providerName, "Provider Name");
        StringUtil_1.StringUtil.requireNonBlank(params.credentialId, "Credential ID");
        StringUtil_1.StringUtil.requireNonBlank(params.pin, "PIN");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.authorizationContext, "Authorization Context");
    }
    static validateFieldOptions(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Field Options params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.visible, "Visible");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.location, "Location");
        StringUtil_1.StringUtil.requireNonBlank(params.fieldName, "Field Name");
        if (!ObjectUtil_1.ObjectUtil.isUndefined(params.pageNumber)) {
            ObjectUtil_1.ObjectUtil.requireValidPositiveInteger(params.pageNumber, "Page Number");
        }
    }
    static validateRFC3161TSAOptions(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "TSA Option params");
        StringUtil_1.StringUtil.requireNonBlank(params.url, "URL");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.credentialAuthParameters, "Credential Auth parameters");
    }
    static validateTSAAuthCredentials(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "TSA Auth Credential params");
        StringUtil_1.StringUtil.requireNonBlank(params.username, "Username");
        StringUtil_1.StringUtil.requireNonBlank(params.password, "Password");
    }
    static validatePDFElectronicSealJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "PDF Electronic Seal Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "PDF Electronic Seal parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.sealImageAsset, "Seal Image Asset");
        if (params.sealImageAsset &&
            ((params.sealImageAsset instanceof ExternalAsset_1.ExternalAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) ||
                (params.sealImageAsset instanceof CloudAsset_1.CloudAsset && params.inputAsset instanceof ExternalAsset_1.ExternalAsset))) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_SEAL_ASSET_VALIDATE}`);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateAutotagPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Auto-tag PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "Auto-tag PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateCombinePDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Combine PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Combine PDF parameters");
        params.params.validate();
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.params.assetsToCombine[0].asset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateCompressPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Compress PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "Compress PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateCreatePDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Create PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "Create PDF parameters");
    }
    static validateDeletePagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Delete Pages Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Delete Pages parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateDocumentMergeJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Document Merge Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Document Merge parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateExportPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Export PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Export PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateExportPDFToImagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Export PDF to images Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Export PDF to images parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateExtractPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Extract PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "Extract PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateHTMLToPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "HTML To PDF Job params");
        if (ObjectUtil_1.ObjectUtil.isUndefined(params.inputAsset) && ObjectUtil_1.ObjectUtil.isUndefined(params.inputURL)) {
            throw new TypeError("At least one of Input Asset or Input URL should be provided");
        }
        if (!ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.inputAsset) && !ObjectUtil_1.ObjectUtil.isUndefinedOrNull(params.inputURL)) {
            throw new TypeError("Only one of Input Asset or Input URL should be provided");
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.inputURL, "Input URL");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "HTML To PDF parameters");
    }
    static validateInsertPagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Insert Pages Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Insert Pages parameters");
        params.params.validate();
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.params.baseAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateLinearizePDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Linearize PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateOCRPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "OCR PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "OCR parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validatePDFPropertiesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "PDF Properties Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.params, "PDF Properties parameters");
    }
    static validateProtectPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Protect PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Protect PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateRemoveProtectionJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Remove Protection Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Remove Protection parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateReorderPagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Reorder Pages Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Reorder Pages parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.params.asset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateReplacePagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Replace Pages Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Replace Pages parameters");
        params.params.validate();
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.params.baseAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateRotatePagesJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Rotate Pages Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Rotate Pages parameters");
        params.params.validate();
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateSplitPDFJobParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Split PDF Job params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.inputAsset, "Input Asset");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.params, "Split PDF parameters");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.outputAsset, "Output Asset");
        if (params.outputAsset && params.inputAsset instanceof CloudAsset_1.CloudAsset) {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.SET_OUTPUT_VALIDATE}`);
        }
    }
    static validateTokenCredentials(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Token Credential params");
        StringUtil_1.StringUtil.requireNonBlank(params.clientId, "Client ID");
        StringUtil_1.StringUtil.requireNonBlank(params.token, "Token");
    }
    static validateServicePrincipalCredentials(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Service Principal Credential params");
        StringUtil_1.StringUtil.requireNonBlank(params.clientId, "Client ID");
        StringUtil_1.StringUtil.requireNonBlank(params.clientSecret, "Client Secret");
    }
    static validatePDFServicesParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "PDF Services params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.credentials, "Credentials");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.clientConfig, "Client Config");
    }
    static validateUploadParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Upload params");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.readStream, "Read Stream");
        StringUtil_1.StringUtil.requireNonBlank(params.mimeType, "Mime Type");
    }
    static validateSubmitParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Submit params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.job, "PDFServices job");
        ObjectUtil_1.ObjectUtil.requireNonNull(params.notifiers, "Notify Config List");
        params.notifiers?.forEach((notifierConfig) => {
            ObjectUtil_1.ObjectUtil.requireNonNull(notifierConfig, "Notify Config List elements");
        });
    }
    static validateGetJobResultParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Get job result params");
        StringUtil_1.StringUtil.requireNonBlank(params.pollingURL, "Polling URL");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.resultType, "Result Type");
    }
    static validateGetJobStatusParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Get job status params");
        StringUtil_1.StringUtil.requireNonBlank(params.pollingURL, "Polling URL");
    }
    static validateGetContentParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Get Content params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.asset, "Asset to get content");
    }
    static validateDeleteAssetParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Delete Asset params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.asset, "Asset to delete");
    }
    static validateRefreshDownloadURIParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Refresh Download URI params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.asset, "Asset to refresh download URI");
    }
    static validateUploadAssetsParams(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Upload Assets params");
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params.streamAssets, "Stream Assets");
        params.streamAssets.forEach((streamAsset) => {
            this.validateUploadParams(streamAsset);
        });
    }
    static validateFieldLocation(params) {
        ObjectUtil_1.ObjectUtil.requireNonNullOrUndefined(params, "Field Location params");
        ObjectUtil_1.ObjectUtil.requireValidNonNegativeInteger(params.left, "Left");
        ObjectUtil_1.ObjectUtil.requireValidNonNegativeInteger(params.top, "Top");
        ObjectUtil_1.ObjectUtil.requireValidNonNegativeInteger(params.right, "Right");
        ObjectUtil_1.ObjectUtil.requireValidNonNegativeInteger(params.bottom, "Bottom");
    }
}
exports.ValidationUtil = ValidationUtil;
ValidationUtil.PASSWORD_MAX_LENGTH = 128;
ValidationUtil.PAGE_ACTIONS_MAX_LIMIT = 200;
ValidationUtil.USER_STRING = "User";
ValidationUtil.OWNER_STRING = "Owner";
ValidationUtil.REMOVE_PROTECTION_PASSWORD_MAX_LENGTH = 150;
ValidationUtil.SPLIT_PDF_OUTPUT_COUNT_LIMIT = 20;
//# sourceMappingURL=ValidationUtil.js.map