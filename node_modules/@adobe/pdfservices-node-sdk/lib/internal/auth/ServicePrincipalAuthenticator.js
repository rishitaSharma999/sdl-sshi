"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServicePrincipalAuthenticator = void 0;
const uuid_1 = require("uuid");
const SessionToken_1 = require("./SessionToken");
const HttpBaseRequest_1 = require("../http/HttpBaseRequest");
const HttpMethod_1 = require("../http/HttpMethod");
const RequestKey_1 = require("../constants/RequestKey");
const AuthenticationMethod_1 = require("./AuthenticationMethod");
const DefaultRequestHeaders_1 = require("../http/DefaultRequestHeaders");
const HttpClient_1 = require("../http/HttpClient");
const Logger_1 = __importDefault(require("../Logger"));
class ServicePrincipalAuthenticator {
    constructor(servicePrincipalCredentials, clientConfig) {
        this.isRefreshingTokenPromise = null; // Promise to track token refresh
        this.servicePrincipalCredentials = servicePrincipalCredentials;
        ServicePrincipalAuthenticator.TOKEN_ENDPOINT = `${clientConfig.pdfServicesUri}/${ServicePrincipalAuthenticator.IMS_PROXY_TOKEN_ENDPOINT}`;
    }
    get clientId() {
        return this.servicePrincipalCredentials.clientId;
    }
    async getSessionToken(requestConfig) {
        // Check if token is expired or not present
        if (this.sessionToken && this.isTokenNonNullAndValid()) {
            Logger_1.default.debug("Session Token is valid, won't be refreshed.");
            return this.sessionToken;
        }
        // If token is expired or not present, and refresh is not already in progress
        if (!this.isRefreshingTokenPromise) {
            Logger_1.default.debug("Session token has been expired or not present. Refreshing!");
            // Initiate token refresh and store the promise to track its completion
            this.isRefreshingTokenPromise = this.refreshSessionToken(requestConfig).finally(() => {
                // Clear the promise after token refresh is complete
                this.isRefreshingTokenPromise = null;
            });
        }
        else {
            Logger_1.default.debug("Session token refresh is already in progress. Waiting for it to complete.");
        }
        // Wait for token refresh to complete before returning the token
        await this.isRefreshingTokenPromise;
        return this.sessionToken;
    }
    isTokenNonNullAndValid() {
        if (!this.sessionToken || !this.sessionToken.expiresAt) {
            return false;
        }
        const sessionTokenExpiryTime = this.sessionToken.expiresAt, diff = sessionTokenExpiryTime.getTime() - new Date().getTime();
        return diff > 2 * 60 * 1000; // 2 minutes in milliseconds
    }
    async refreshSessionToken(requestConfig) {
        const httpRequest = new HttpBaseRequest_1.HttpBaseRequest({
            httpMethod: HttpMethod_1.HttpMethod.POST,
            uriTemplate: ServicePrincipalAuthenticator.TOKEN_ENDPOINT,
            requestKey: RequestKey_1.RequestKey.AUTHN_PDF_SERVICES_SPC,
            authenticationMethod: AuthenticationMethod_1.AuthenticationMethod.UNAUTHENTICATED,
            headers: {
                "x-request-id": (0, uuid_1.v4)(),
                "Content-Type": DefaultRequestHeaders_1.DefaultRequestHeaders.CONTENT_TYPE_FORM_URLENCODED,
                "x-api-app-info": DefaultRequestHeaders_1.DefaultRequestHeaders.APP_API_INFO
            },
            data: {
                client_id: this.servicePrincipalCredentials.clientId,
                client_secret: this.servicePrincipalCredentials.clientSecret
            },
            httpRequestConfig: requestConfig
        }), client = HttpClient_1.HttpClient.getInstance(), response = await client.execute(httpRequest);
        this.sessionToken = new SessionToken_1.SessionToken(response.baseResponseDto.accessToken, new Date(new Date().getTime() + response.baseResponseDto.expiryInterval * 1000));
        return this.sessionToken;
    }
}
exports.ServicePrincipalAuthenticator = ServicePrincipalAuthenticator;
ServicePrincipalAuthenticator.IMS_PROXY_TOKEN_ENDPOINT = "token";
//# sourceMappingURL=ServicePrincipalAuthenticator.js.map