"use strict";
/*
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientConfig = void 0;
const fs_1 = __importDefault(require("fs"));
const ProxyServerConfig_1 = require("./proxy/ProxyServerConfig");
const Region_1 = require("../Region");
const ValidationUtil_1 = require("../internal/util/ValidationUtil");
const GlobalConfig_1 = require("../internal/GlobalConfig");
const PDFServicesUri_1 = require("../internal/constants/PDFServicesUri");
const StringUtil_1 = require("../internal/util/StringUtil");
const CustomErrorMessages_1 = require("../internal/constants/CustomErrorMessages");
const ProxyScheme_1 = require("./proxy/ProxyScheme");
const UsernamePasswordCredentials_1 = require("./proxy/UsernamePasswordCredentials");
const ObjectUtil_1 = require("../internal/util/ObjectUtil");
/**
 * Encapsulates the API request configurations.
 */
class ClientConfig {
    /**
     * Constructs a new `ClientConfig` instance.
     *
     * @param params - The parameters for constructing a new `ClientConfig` instance.
     * @param [params.timeout] - The timeout for the API request. Default value is 10000 milliseconds.
     * @param [params.region] - A {@link Region} instance. Default value is {@link Region#US US}.
     * @param [params.proxyServerConfig] - A {@link ProxyServerConfig} instance for providing proxy server
     * configuration.
     * @param [params.filePath] - The path to the file containing the client configuration.
     * <p>
     * JSON structure:
     * <pre>
     * {
     *   "timeout": "15000",
     *   "proxyServerConfig": {
     *     "host": "127.0.0.1",
     *     "port": "8080",
     *     "scheme": "https",
     *     "usernamePasswordCredentials": {
     *       "username": "username",
     *       "password": "password"
     *     }
     *   },
     *   "region": "EU"
     * }
     * </pre>
     * @remarks
     * This documentation indicates that users can specify client configurations such as timeout, region, and proxy
     * settings either directly as parameters or via a configuration file provided using the filePath property.
     * If a configuration is specified in both ways, the settings from the file (specified by filePath) will take
     * precedence.
     */
    constructor(params) {
        ValidationUtil_1.ValidationUtil.validateClientConfigParams(params);
        this._timeout = params.timeout ?? GlobalConfig_1.GlobalConfig.DEFAULT_TIMEOUT_IN_MS;
        this._pdfServicesUri = PDFServicesUri_1.PDFServicesUri.getURIForRegion(params.region);
        this._proxyServerConfig = params.proxyServerConfig;
        if (params.filePath) {
            this.fromFile(params.filePath);
        }
    }
    /**
     * Returns the timeout for the API request.
     */
    get timeout() {
        return this._timeout;
    }
    /**
     * Returns the PDF Services URI.
     * @internal Used internally by this SDK, not intended to be called by clients.
     */
    get pdfServicesUri() {
        return this._pdfServicesUri;
    }
    /**
     * Returns the proxy server configuration.
     */
    get proxyServerConfig() {
        return this._proxyServerConfig;
    }
    fromFile(clientConfigFilePath) {
        const clientConfig = JSON.parse(fs_1.default.readFileSync(clientConfigFilePath, "utf8")), regionNode = clientConfig[ClientConfig.REGION];
        if (regionNode) {
            if (!Object.values(Region_1.Region).includes(regionNode.toUpperCase()))
                throw new TypeError("Invalid value for region code. Must be either US or EU.");
            this._pdfServicesUri = PDFServicesUri_1.PDFServicesUri.getURIForRegion(regionNode.toUpperCase());
        }
        const pdfServicesNode = clientConfig[ClientConfig.PDF_SERVICES];
        if (pdfServicesNode) {
            const pdfServicesUriNode = pdfServicesNode[ClientConfig.PDF_SERVICES_URI];
            if (pdfServicesUriNode) {
                this._pdfServicesUri = pdfServicesUriNode;
            }
        }
        const timeoutNode = clientConfig[ClientConfig.TIMEOUT_KEY];
        if (timeoutNode && StringUtil_1.StringUtil.isPositiveInteger(timeoutNode)) {
            this._timeout = parseInt(timeoutNode, 10);
        }
        else if (timeoutNode) {
            throw new TypeError(`Invalid value for timeout ${timeoutNode}. Must be a valid integer greater than 0`);
        }
        const proxyServerConfigNode = clientConfig[ClientConfig.PROXY_SERVER_CONFIG];
        if (!ObjectUtil_1.ObjectUtil.isUndefined(proxyServerConfigNode)) {
            this._proxyServerConfig = this.createProxyServerConfig(clientConfig);
        }
    }
    createProxyServerConfig(clientConfig) {
        let host, port, scheme, credentials;
        const proxyServerConfigNode = clientConfig[ClientConfig.PROXY_SERVER_CONFIG];
        ObjectUtil_1.ObjectUtil.requireNonNull(proxyServerConfigNode, "Proxy server config");
        const proxyHostNode = proxyServerConfigNode[ClientConfig.PROXY_HOST];
        if (proxyHostNode) {
            host = proxyHostNode;
        }
        else {
            throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.GENERIC_CAN_NOT_BE_NULL_OR_EMPTY}, "Proxy host"`);
        }
        const proxyPortNode = proxyServerConfigNode[ClientConfig.PROXY_PORT];
        if (proxyPortNode && StringUtil_1.StringUtil.isNonNegativeInteger(proxyPortNode)) {
            port = parseInt(proxyPortNode, 10);
        }
        else {
            throw new RangeError("Invalid value for proxy port. It should be >= 0 and < 65536 ");
        }
        const proxySchemeNode = proxyServerConfigNode[ClientConfig.PROXY_SCHEME];
        if (proxySchemeNode) {
            if (proxySchemeNode) {
                if (!Object.values(ProxyScheme_1.ProxyScheme).includes(proxySchemeNode.toLowerCase()))
                    throw new TypeError("Invalid value for proxy scheme. Must be either http or https.");
                scheme = proxySchemeNode.toLowerCase();
            }
            else {
                throw new TypeError(`${CustomErrorMessages_1.CustomErrorMessages.GENERIC_CAN_NOT_BE_NULL_OR_EMPTY}, "Proxy scheme"`);
            }
        }
        const credentialsNode = proxyServerConfigNode[ClientConfig.PROXY_CREDENTIALS];
        if (credentialsNode) {
            const username = credentialsNode[ClientConfig.PROXY_USERNAME], password = credentialsNode[ClientConfig.PROXY_PASSWORD];
            StringUtil_1.StringUtil.requireNonBlank(username, "Username");
            StringUtil_1.StringUtil.requireNonBlank(password, "Password");
            credentials = new UsernamePasswordCredentials_1.UsernamePasswordCredentials({ username, password });
        }
        return new ProxyServerConfig_1.ProxyServerConfig({ host, port, scheme, credentials });
    }
}
exports.ClientConfig = ClientConfig;
ClientConfig.PDF_SERVICES = "pdf_services";
ClientConfig.PDF_SERVICES_URI = "pdf_services_uri";
ClientConfig.TIMEOUT_KEY = "timeout";
ClientConfig.PROXY_HOST = "host";
ClientConfig.PROXY_SERVER_CONFIG = "proxyServerConfig";
ClientConfig.PROXY_PORT = "port";
ClientConfig.PROXY_SCHEME = "proxyScheme";
ClientConfig.REGION = "region";
ClientConfig.PROXY_CREDENTIALS = "usernamePasswordCredentials";
ClientConfig.PROXY_USERNAME = "username";
ClientConfig.PROXY_PASSWORD = "password";
//# sourceMappingURL=ClientConfig.js.map